package mongodb

import (
	"context"
	"fmt"
	"os"
	"testing"
	"time"

	"github.com/pilab-dev/shadow-sso/domain"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.mongodb.org/mongo-driver/v2/mongo"
	"go.mongodb.org/mongo-driver/v2/mongo/options"
	// "go.mongodb.org/mongo-driver/v2/bson" // For direct BSON if needed
)

// Helper function to setup DB for SessionRepository tests
func setupSessionRepoTest(t *testing.T) (domain.SessionRepository, func(), error) {
	mongoURI := os.Getenv("TEST_MONGO_URI")
	if mongoURI == "" {
		mongoURI = "mongodb://localhost:27017"
	}
	dbName := fmt.Sprintf("test_sso_session_repo_%d", time.Now().UnixNano())

	ctx, cancelSetup := context.WithTimeout(context.Background(), 20*time.Second)
	defer cancelSetup()

	// Direct client connection for test isolation
	client, err := mongo.Connect(ctx, options.Client().ApplyURI(mongoURI).SetConnectTimeout(10*time.Second))
	if err != nil {
		return nil, func() {}, fmt.Errorf("mongo.Connect failed for session repo test: %w", err)
	}
	if errPing := client.Ping(ctx, nil); errPing != nil {
		client.Disconnect(ctx)
		return nil, func() {}, fmt.Errorf("mongo.Ping failed for session repo test: %w", errPing)
	}
	db := client.Database(dbName)

	sessionRepo, err := NewSessionRepositoryMongo(ctx, db) // Creates collection and indexes
	if err != nil {
		client.Disconnect(ctx)
		return nil, func() {}, fmt.Errorf("NewSessionRepositoryMongo failed: %w", err)
	}

	cleanupFunc := func() {
		mainCtx := context.Background()
		if errDbDrop := db.Drop(mainCtx); errDbDrop != nil {
			t.Logf("Warning: failed to drop database %s during cleanup: %v", dbName, errDbDrop)
		}
		if errDisconnect := client.Disconnect(mainCtx); errDisconnect != nil {
			t.Logf("Warning: failed to disconnect test client during cleanup: %v", errDisconnect)
		}
	}
	return sessionRepo, cleanupFunc, nil
}

func TestSessionRepositoryMongo_Integration(t *testing.T) {
	if os.Getenv("TEST_MONGO_URI") == "" && os.Getenv("CI") != "" {
		t.Skip("Skipping MongoDB integration tests: TEST_MONGO_URI not set and CI environment detected.")
	}

	repo, cleanup, err := setupSessionRepoTest(t)
	require.NoError(t, err, "Failed to setup SessionRepository test")
	defer cleanup()

	ctx := context.Background()
	now := time.Now().UTC().Truncate(time.Millisecond) // Truncate for consistent time comparison

	userID1 := "user-id-for-sessions-1"
	userID2 := "user-id-for-sessions-2"

	session1 := &domain.Session{
		// ID generated by StoreSession if empty via NewObjectID()
		UserID:    userID1,
		TokenID:   "jti-session1-tokenid", // Unique JWT ID
		UserAgent: "Mozilla/5.0 TestAgent1",
		IPAddress: "192.168.1.1",
		ExpiresAt: now.Add(1 * time.Hour),
		IsRevoked: false,
		// CreatedAt will be set by StoreSession
	}
	session2 := &domain.Session{
		UserID:    userID1, // Same user, different session
		TokenID:   "jti-session2-tokenid",
		UserAgent: "Mozilla/5.0 TestAgent2",
		IPAddress: "192.168.1.2",
		ExpiresAt: now.Add(2 * time.Hour),
		IsRevoked: false,
	}
	session3User2 := &domain.Session{
		UserID:    userID2,
		TokenID:   "jti-session3-user2-tokenid",
		UserAgent: "Mozilla/5.0 TestAgent3",
		IPAddress: "192.168.1.3",
		ExpiresAt: now.Add(30 * time.Minute),
		IsRevoked: true, // Initially revoked
	}

	t.Run("StoreSessionAndGetByID", func(t *testing.T) {
		err := repo.StoreSession(ctx, session1)
		require.NoError(t, err, "StoreSession for session1 should succeed")
		require.NotEmpty(t, session1.ID, "session1 ID should be populated")
		require.False(t, session1.CreatedAt.IsZero(), "session1 CreatedAt should be populated")

		fetchedSession, err := repo.GetSessionByID(ctx, session1.ID)
		require.NoError(t, err, "GetSessionByID for session1 should succeed")
		require.NotNil(t, fetchedSession)
		assert.Equal(t, session1.UserID, fetchedSession.UserID)
		assert.Equal(t, session1.TokenID, fetchedSession.TokenID)
		assert.Equal(t, session1.IPAddress, fetchedSession.IPAddress)
		assert.WithinDuration(t, session1.ExpiresAt, fetchedSession.ExpiresAt, time.Second)

		// Store other sessions for later tests
		err = repo.StoreSession(ctx, session2)
		require.NoError(t, err, "StoreSession for session2 should succeed")
		err = repo.StoreSession(ctx, session3User2)
		require.NoError(t, err, "StoreSession for session3User2 should succeed")
	})

	t.Run("GetSessionByID_NotFound", func(t *testing.T) {
		_, err := repo.GetSessionByID(ctx, "non-existent-session-id")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "session not found by ID")
	})

	t.Run("GetSessionByTokenID", func(t *testing.T) {
		fetchedSession, err := repo.GetSessionByTokenID(ctx, session1.TokenID)
		require.NoError(t, err, "GetSessionByTokenID for session1's tokenID should succeed")
		require.NotNil(t, fetchedSession)
		assert.Equal(t, session1.ID, fetchedSession.ID)
	})

	t.Run("GetSessionByTokenID_NotFound", func(t *testing.T) {
		_, err := repo.GetSessionByTokenID(ctx, "non-existent-jti")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "session not found by TokenID")
	})

	t.Run("UpdateSession_Revoke", func(t *testing.T) {
		// session2 is currently not revoked
		session2ToUpdate, errGet := repo.GetSessionByID(ctx, session2.ID)
		require.NoError(t, errGet)
		require.NotNil(t, session2ToUpdate)

		session2ToUpdate.IsRevoked = true
		// Optionally, update ExpiresAt to now if revoking means immediate expiry
		// session2ToUpdate.ExpiresAt = time.Now().UTC().Truncate(time.Millisecond)

		err := repo.UpdateSession(ctx, session2ToUpdate)
		require.NoError(t, err, "UpdateSession to revoke session2 should succeed")

		fetchedSession, err := repo.GetSessionByID(ctx, session2.ID)
		require.NoError(t, err)
		require.NotNil(t, fetchedSession)
		assert.True(t, fetchedSession.IsRevoked)
	})

	t.Run("ListSessionsByUserID", func(t *testing.T) {
		// For userID1: session1 (active), session2 (now revoked)
		// For userID2: session3User2 (revoked)

		// List all for userID1
		sessionsUser1, err := repo.ListSessionsByUserID(ctx, userID1, domain.SessionFilter{})
		require.NoError(t, err)
		assert.Len(t, sessionsUser1, 2, "Should be 2 sessions total for userID1")

		// List only active for userID1
		activeFilter := domain.SessionFilter{IsRevoked: new(bool)} // *IsRevoked = false
		*activeFilter.IsRevoked = false // Explicitly set to false for clarity
		sessionsUser1Active, err := repo.ListSessionsByUserID(ctx, userID1, activeFilter)
		require.NoError(t, err)
		assert.Len(t, sessionsUser1Active, 1, "Should be 1 active session for userID1")
		if len(sessionsUser1Active) == 1 {
			assert.Equal(t, session1.ID, sessionsUser1Active[0].ID)
		}

		// List by IP for userID1
		ipFilter := domain.SessionFilter{IPAddress: "192.168.1.1"}
		sessionsUser1IP, err := repo.ListSessionsByUserID(ctx, userID1, ipFilter)
		require.NoError(t, err)
		assert.Len(t, sessionsUser1IP, 1, "Should be 1 session for userID1 with IP 192.168.1.1")
		if len(sessionsUser1IP) == 1 {
			assert.Equal(t, session1.ID, sessionsUser1IP[0].ID)
		}
	})

	t.Run("DeleteSessionsByUserID", func(t *testing.T) {
		// userID1 has session1 (active) and session2 (revoked)
		// Delete all for userID1 except session1
		deletedCount, err := repo.DeleteSessionsByUserID(ctx, userID1, session1.ID)
		require.NoError(t, err)
		assert.Equal(t, int64(1), deletedCount, "Should have deleted 1 session (session2) for userID1")

		sessionsUser1AfterDelete, err := repo.ListSessionsByUserID(ctx, userID1, domain.SessionFilter{})
		require.NoError(t, err)
		assert.Len(t, sessionsUser1AfterDelete, 1, "Only session1 should remain for userID1")
		if len(sessionsUser1AfterDelete) == 1 {
			assert.Equal(t, session1.ID, sessionsUser1AfterDelete[0].ID)
		}

		// Delete remaining session1 for userID1 (all for user)
		deletedCount, err = repo.DeleteSessionsByUserID(ctx, userID1)
		require.NoError(t, err)
		assert.Equal(t, int64(1), deletedCount, "Should have deleted remaining session for userID1")

		sessionsUser1Final, err := repo.ListSessionsByUserID(ctx, userID1, domain.SessionFilter{})
		require.NoError(t, err)
		assert.Empty(t, sessionsUser1Final, "No sessions should remain for userID1")
	})

	t.Run("DeleteSession", func(t *testing.T) {
		// session3User2 for userID2 is still present
		err := repo.DeleteSession(ctx, session3User2.ID)
		require.NoError(t, err, "DeleteSession for session3User2 should succeed")

		_, err = repo.GetSessionByID(ctx, session3User2.ID)
		assert.Error(t, err, "GetSessionByID for session3User2 should fail after deletion")
		assert.Contains(t, err.Error(), "session not found by ID")
	})
}

// Helper for domain.SessionFilter IsRevoked field
// func boolPtr(b bool) *bool { return &b } // Use this in tests if needed, e.g. activeFilter.IsRevoked = boolPtr(false)
// The test code `activeFilter := domain.SessionFilter{IsRevoked: new(bool)}` correctly creates a pointer to false.
// Explicitly setting `*activeFilter.IsRevoked = false` for clarity.
