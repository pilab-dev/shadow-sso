package mongodb_test

import (
	"context"
	"fmt"
	"os"
	"strconv"
	"testing"
	"time"

	"github.com/pilab-dev/shadow-sso/domain"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require" // For cleanup
	"go.mongodb.org/mongo-driver/v2/mongo"
	"go.mongodb.org/mongo-driver/v2/mongo/options"

	"github.com/pilab-dev/shadow-sso/mongodb"
)

// Helper function to setup DB for tests
// Returns a UserRepositoryMongo, a cleanup function, and an error
func setupUserRepoTest(t *testing.T) (domain.UserRepository, func(), error) {
	mongoURI := os.Getenv("MONGO_TEST_URI") // Using MONGO_TEST_URI
	if mongoURI == "" {
		mongoURI = "mongodb://localhost:27017" // Default for local testing
	}
	dbName := "test_sso_user_repo_" + strconv.FormatInt(time.Now().UnixNano(), 10) // Unique DB name for test isolation

	ctx, cancelSetup := context.WithTimeout(context.Background(), 20*time.Second)
	defer cancelSetup()

	// For tests, it's better if InitMongoDB can be called multiple times with different DBs,
	// or if we have a way to get a client and select a DB without global instances.
	// Assuming InitMongoDB with a unique dbName works for test isolation or is idempotent for client part.
	// If InitMongoDB uses sync.Once for client and db, subsequent calls with different dbName might not switch DB.
	// This setup might need a more robust test DB handling strategy.
	// For this subtask, proceeding with assumption that a test DB can be obtained.
	// A simple approach for testing might be to directly use mongo.Connect and get a db instance.
	// Let's refine this to directly connect for test isolation if InitMongoDB is strictly singleton.

	client, err := mongo.Connect(options.Client().ApplyURI(mongoURI).SetConnectTimeout(10 * time.Second))
	if err != nil {
		return nil, func() {}, fmt.Errorf("mongo.Connect failed: %w", err)
	}
	if err := client.Ping(ctx, nil); err != nil {
		client.Disconnect(ctx)
		return nil, func() {}, fmt.Errorf("mongo.Ping failed: %w", err)
	}
	db := client.Database(dbName)

	// Create repository instance
	userRepo, err := mongodb.NewUserRepositoryMongo(ctx, db) // NewUserRepositoryMongo already handles index creation.
	if err != nil {
		client.Disconnect(ctx)
		return nil, func() {}, fmt.Errorf("NewUserRepositoryMongo failed: %w", err)
	}

	cleanupFunc := func() {
		if dropErr := db.Drop(context.Background()); dropErr != nil {
			t.Logf("Warning: failed to drop test database %s during cleanup: %v", dbName, dropErr)
		}
		if disconnectErr := client.Disconnect(context.Background()); disconnectErr != nil {
			t.Logf("Warning: failed to disconnect test client during cleanup: %v", disconnectErr)
		}
	}

	return userRepo, cleanupFunc, nil
}

func TestUserRepositoryMongo_Integration(t *testing.T) {
	// Skip if no MongoDB is available (e.g. in CI without service)
	if os.Getenv("MONGO_TEST_URI") == "" { // Standardized skip condition
		t.Skip("Skipping MongoDB integration test: MONGO_TEST_URI not set")
	}

	userRepo, cleanup, err := setupUserRepoTest(t)
	require.NoError(t, err, "Failed to setup user repo test")
	defer cleanup()

	ctx := context.Background()

	t.Run("CreateAndGetUserByEmail", func(t *testing.T) {
		newUser := &domain.User{
			// ID will be generated by CreateUser if empty (using NewObjectID)
			Email:        "testuser@example.com",
			PasswordHash: "hashedpassword",
			Status:       domain.UserStatusActive,
			FirstName:    "Test",
			LastName:     "User",
		}

		err := userRepo.CreateUser(ctx, newUser)
		require.NoError(t, err, "CreateUser should not error")
		require.NotEmpty(t, newUser.ID, "User ID should be populated after CreateUser")
		require.NotZero(t, newUser.CreatedAt, "CreatedAt should be populated")
		require.NotZero(t, newUser.UpdatedAt, "UpdatedAt should be populated")

		fetchedUser, err := userRepo.GetUserByEmail(ctx, "testuser@example.com")
		require.NoError(t, err, "GetUserByEmail should not error for existing user")
		require.NotNil(t, fetchedUser, "Fetched user should not be nil")

		assert.Equal(t, newUser.ID, fetchedUser.ID)
		assert.Equal(t, "testuser@example.com", fetchedUser.Email)
		assert.Equal(t, "hashedpassword", fetchedUser.PasswordHash)
		assert.Equal(t, domain.UserStatusActive, fetchedUser.Status)
		// Comparing time.Time structs directly can be flaky due to monotonic clock differences.
		// Compare Unix time or use assert.WithinDuration.
		assert.Equal(t, newUser.CreatedAt.Unix(), fetchedUser.CreatedAt.Unix())
	})

	t.Run("GetUserByEmail_NotFound", func(t *testing.T) {
		_, err := userRepo.GetUserByEmail(ctx, "nonexistent@example.com")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "user not found", "Error message should indicate not found")
	})

	t.Run("CreateUser_DuplicateEmail", func(t *testing.T) {
		user1 := &domain.User{Email: "duplicate@example.com", PasswordHash: "pass1", Status: domain.UserStatusActive}
		err := userRepo.CreateUser(ctx, user1)
		// This test assumes the collection is clean for each sub-test, or that duplicate@example.com wasn't used by CreateAndGetUserByEmail.
		// If CreateAndGetUserByEmail used "duplicate@example.com", this will fail.
		// The current setupUserTest drops the DB, so this should be fine.
		// However, "testuser@example.com" was used. Let's use a different email for this test.
		user1.Email = "unique-for-duplicate-test@example.com"
		err = userRepo.CreateUser(ctx, user1)
		require.NoError(t, err, "First CreateUser should succeed")

		user2 := &domain.User{Email: "unique-for-duplicate-test@example.com", PasswordHash: "pass2", Status: domain.UserStatusActive}
		err = userRepo.CreateUser(ctx, user2)
		assert.Error(t, err, "Second CreateUser with same email should fail")
		assert.Contains(t, err.Error(), "already exists", "Error message for duplicate email")
	})

	// TODO: Add tests for GetUserByID, UpdateUser, DeleteUser, ListUsers

	// User for Update and Delete tests
	updateUser := &domain.User{
		Email:        "updateuser@example.com",
		PasswordHash: "initialhash",
		Status:       domain.UserStatusActive,
		FirstName:    "Update",
		LastName:     "Me",
	}
	err = userRepo.CreateUser(ctx, updateUser) // Create user for update/delete tests
	require.NoError(t, err, "Setup: CreateUser for update/delete tests should succeed")
	require.NotEmpty(t, updateUser.ID, "Setup: updateUser ID should be populated")

	t.Run("GetUserByID", func(t *testing.T) {
		fetchedUser, err := userRepo.GetUserByID(ctx, updateUser.ID)
		require.NoError(t, err, "GetUserByID should not error for existing user")
		require.NotNil(t, fetchedUser)
		assert.Equal(t, updateUser.Email, fetchedUser.Email)
	})

	t.Run("GetUserByID_NotFound", func(t *testing.T) {
		_, err := userRepo.GetUserByID(ctx, "nonexistent-id-string") // Or use a valid but non-existent ObjectID hex
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "user not found")
	})

	t.Run("UpdateUser", func(t *testing.T) {
		updateUser.FirstName = "UpdatedFirstName"
		updateUser.Status = domain.UserStatusLocked // Assuming UserStatusLocked is defined
		originalUpdatedAt := updateUser.UpdatedAt   // Store before update

		err := userRepo.UpdateUser(ctx, updateUser)
		require.NoError(t, err, "UpdateUser should not error")

		fetchedUser, errGet := userRepo.GetUserByID(ctx, updateUser.ID)
		require.NoError(t, errGet)
		require.NotNil(t, fetchedUser)
		assert.Equal(t, "UpdatedFirstName", fetchedUser.FirstName)
		assert.Equal(t, domain.UserStatusLocked, fetchedUser.Status)
		// UpdatedAt should be more recent, or at least equal if time resolution is low / operations are too fast
		assert.True(t, fetchedUser.UpdatedAt.UnixNano() >= originalUpdatedAt.UnixNano(), "UpdatedAt should be more recent or same")
		if fetchedUser.UpdatedAt.UnixNano() == originalUpdatedAt.UnixNano() {
			t.Logf("Warning: UpdatedAt did not change, might be due to very fast execution or low time resolution. Original: %v, New: %v", originalUpdatedAt, fetchedUser.UpdatedAt)
		}
	})

	t.Run("UpdateUser_NotFound", func(t *testing.T) {
		nonExistentUser := &domain.User{
			ID:        "nonexistentid12345", // A non-existent ID
			Email:     "no@example.com",
			FirstName: "No",
		}
		err := userRepo.UpdateUser(ctx, nonExistentUser)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "user not found for update")
	})

	t.Run("ListUsers_Pagination", func(t *testing.T) {
		// Count existing users from previous sub-tests within this TestUserRepositoryMongo_Integration run
		// (e.g., "testuser@example.com", "unique-for-duplicate-test@example.com", "updateuser@example.com")
		initialUserCount := 0
		allUsersBeforeListTest, _, _ := userRepo.ListUsers(ctx, "", 1000) // Get all current users
		initialUserCount = len(allUsersBeforeListTest)

		// Create 3 more users for a total of at least initialUserCount + 3
		for i := 0; i < 3; i++ {
			err := userRepo.CreateUser(ctx, &domain.User{
				Email: fmt.Sprintf("listuser%d@example.com", i), PasswordHash: "hash", Status: domain.UserStatusActive,
			})
			require.NoError(t, err)
		}
		totalExpectedUsers := initialUserCount + 3

		// Page 1: Get 2 users
		usersPage1, nextPageToken1, err := userRepo.ListUsers(ctx, "", 2)
		require.NoError(t, err)
		assert.Len(t, usersPage1, 2, "Page 1 should have 2 users if total >= 2")
		if totalExpectedUsers > 2 {
			assert.NotEmpty(t, nextPageToken1, "Next page token for page 1 should not be empty if total > 2")
		} else {
			assert.Empty(t, nextPageToken1, "Next page token for page 1 should be empty if total <= 2")
		}

		// Page 2: Get next 2 users
		if nextPageToken1 != "" {
			usersPage2, nextPageToken2, err := userRepo.ListUsers(ctx, nextPageToken1, 2)
			require.NoError(t, err)

			expectedPage2Count := 0
			if totalExpectedUsers-2 > 0 { // Users remaining after page 1
				if totalExpectedUsers-2 >= 2 {
					expectedPage2Count = 2
				} else {
					expectedPage2Count = totalExpectedUsers - 2
				}
			}
			assert.Len(t, usersPage2, expectedPage2Count, fmt.Sprintf("Page 2 should have %d users", expectedPage2Count))

			if totalExpectedUsers > 4 {
				assert.NotEmpty(t, nextPageToken2, "Next page token for page 2 should not be empty if total > 4")
			} else {
				assert.Empty(t, nextPageToken2, "Next page token for page 2 should be empty if total <= 4")
			}

			// Page 3: Get remaining users
			if nextPageToken2 != "" {
				usersPage3, nextPageToken3, err := userRepo.ListUsers(ctx, nextPageToken2, 2)
				require.NoError(t, err)
				expectedPage3Count := 0
				if totalExpectedUsers-4 > 0 { // Users remaining after page 2
					if totalExpectedUsers-4 >= 2 {
						expectedPage3Count = 2
					} else {
						expectedPage3Count = totalExpectedUsers - 4
					}
				}
				assert.Len(t, usersPage3, expectedPage3Count, fmt.Sprintf("Page 3 should have %d users", expectedPage3Count))
				if totalExpectedUsers > 6 { // If more than 2+2+2 users
					assert.NotEmpty(t, nextPageToken3, "Next page token for page 3 should not be empty if total > 6")
				} else {
					assert.Empty(t, nextPageToken3, "Next page token for page 3 should be empty if total <= 6")
				}
			}
		}

		// Test listing all in one go if fewer than page size
		allUsers, finalToken, err := userRepo.ListUsers(ctx, "", 10)
		require.NoError(t, err)
		assert.Len(t, allUsers, totalExpectedUsers, "Listing all should match total created in this test scope")
		assert.Empty(t, finalToken, "Final token should be empty when all users are fetched")
	})

	t.Run("DeleteUser", func(t *testing.T) {
		// `updateUser` was created at the start of these sub-tests
		err := userRepo.DeleteUser(ctx, updateUser.ID)
		require.NoError(t, err, "DeleteUser should not error")

		_, err = userRepo.GetUserByID(ctx, updateUser.ID)
		assert.Error(t, err, "GetUserByID should error after DeleteUser")
		assert.Contains(t, err.Error(), "user not found")
	})

	t.Run("DeleteUser_NotFound", func(t *testing.T) {
		err := userRepo.DeleteUser(ctx, "nonexistent-id-for-delete")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "user not found for deletion")
	})
}
