package mongodb_test

import (
	"context"
	"fmt"
	"os"
	"testing"
	"time"

	"github.com/pilab-dev/shadow-sso/domain"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.mongodb.org/mongo-driver/v2/mongo"
	"go.mongodb.org/mongo-driver/v2/mongo/options"

	"github.com/pilab-dev/shadow-sso/mongodb"
)

// Helper function to setup DB for ServiceAccountRepository tests
func setupServiceAccountRepoTest(t *testing.T) (domain.ServiceAccountRepository, func(), error) {
	mongoURI := os.Getenv("MONGO_TEST_URI") // Using MONGO_TEST_URI
	if mongoURI == "" {
		mongoURI = "mongodb://localhost:27017"
	}
	dbName := fmt.Sprintf("test_sso_sa_repo_%d", time.Now().UnixNano())

	ctx, cancelSetup := context.WithTimeout(context.Background(), 20*time.Second)
	defer cancelSetup()

	// Direct client connection for test isolation
	client, err := mongo.Connect(options.Client().ApplyURI(mongoURI).SetConnectTimeout(10 * time.Second))
	if err != nil {
		return nil, func() {}, fmt.Errorf("mongo.Connect failed for sa repo test: %w", err)
	}
	if errPing := client.Ping(ctx, nil); errPing != nil {
		client.Disconnect(ctx)
		return nil, func() {}, fmt.Errorf("mongo.Ping failed for sa repo test: %w", errPing)
	}
	db := client.Database(dbName)

	saRepo, err := mongodb.NewServiceAccountRepositoryMongo(db) // Creates collection and indexes
	if err != nil {
		client.Disconnect(ctx)
		return nil, func() {}, fmt.Errorf("NewServiceAccountRepositoryMongo failed: %w", err)
	}

	cleanupFunc := func() {
		mainCtx := context.Background()
		if errDbDrop := db.Drop(mainCtx); errDbDrop != nil {
			t.Logf("Warning: failed to drop database %s during cleanup: %v", dbName, errDbDrop)
		}
		if errDisconnect := client.Disconnect(mainCtx); errDisconnect != nil {
			t.Logf("Warning: failed to disconnect test client during cleanup: %v", errDisconnect)
		}
	}
	return saRepo, cleanupFunc, nil
}

func TestServiceAccountRepositoryMongo_Integration(t *testing.T) {
	if os.Getenv("MONGO_TEST_URI") == "" { // Standardized skip condition
		t.Skip("Skipping MongoDB integration test: MONGO_TEST_URI not set")
	}

	repo, cleanup, err := setupServiceAccountRepoTest(t)
	require.NoError(t, err, "Failed to setup ServiceAccountRepository test")
	defer cleanup()

	ctx := context.Background()

	sa1 := &domain.ServiceAccount{
		// ID will be generated by CreateServiceAccount if empty via NewObjectID()
		ProjectID:   "project-alpha",
		ClientEmail: "sa1@project-alpha.iam.sso.dev",
		ClientID:    "client-id-for-sa1", // Optional internal client ID
		DisplayName: "Service Account Alpha 1",
		Disabled:    false,
	}
	sa2 := &domain.ServiceAccount{
		ProjectID:   "project-beta",
		ClientEmail: "sa2@project-beta.iam.sso.dev",
		ClientID:    "client-id-for-sa2",
		DisplayName: "Service Account Beta 1",
		Disabled:    true, // Initially disabled
	}

	t.Run("CreateServiceAccount", func(t *testing.T) {
		err := repo.CreateServiceAccount(ctx, sa1)
		require.NoError(t, err, "CreateServiceAccount for sa1 should succeed")
		require.NotEmpty(t, sa1.ID, "sa1 ID should be populated")
		require.NotZero(t, sa1.CreatedAt, "sa1 CreatedAt should be populated")
		require.NotZero(t, sa1.UpdatedAt, "sa1 UpdatedAt should be populated")

		err = repo.CreateServiceAccount(ctx, sa2)
		require.NoError(t, err, "CreateServiceAccount for sa2 should succeed")
		require.NotEmpty(t, sa2.ID, "sa2 ID should be populated")

		// Test duplicate client_email
		sa1DupEmail := &domain.ServiceAccount{ProjectID: "project-gamma", ClientEmail: sa1.ClientEmail}
		err = repo.CreateServiceAccount(ctx, sa1DupEmail)
		require.Error(t, err, "CreateServiceAccount with duplicate client_email should fail")
	})

	t.Run("GetServiceAccount_ByID", func(t *testing.T) {
		fetchedSA, err := repo.GetServiceAccount(ctx, sa1.ID)
		require.NoError(t, err, "GetServiceAccount for sa1 by ID should succeed")
		require.NotNil(t, fetchedSA)
		assert.Equal(t, sa1.ClientEmail, fetchedSA.ClientEmail)
		assert.Equal(t, sa1.DisplayName, fetchedSA.DisplayName)
		assert.False(t, fetchedSA.Disabled)
	})

	t.Run("GetServiceAccount_ByID_NotFound", func(t *testing.T) {
		_, err := repo.GetServiceAccount(ctx, "non-existent-sa-id")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "service account not found")
	})

	t.Run("GetServiceAccount_ByClientEmail", func(t *testing.T) {
		fetchedSA, err := repo.GetServiceAccountByClientEmail(ctx, sa2.ClientEmail)
		require.NoError(t, err, "GetServiceAccountByClientEmail for sa2 should succeed")
		require.NotNil(t, fetchedSA)
		assert.Equal(t, sa2.ID, fetchedSA.ID)
		assert.Equal(t, sa2.DisplayName, fetchedSA.DisplayName)
		assert.True(t, fetchedSA.Disabled)
	})

	t.Run("GetServiceAccount_ByClientEmail_NotFound", func(t *testing.T) {
		_, err := repo.GetServiceAccountByClientEmail(ctx, "nonexistent@email.com")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "service account not found by client_email")
	})

	t.Run("UpdateServiceAccount", func(t *testing.T) {
		// Fetch sa1 to get its current state, especially UpdatedAt
		sa1Fetched, errFetch := repo.GetServiceAccount(ctx, sa1.ID)
		require.NoError(t, errFetch)
		originalUpdatedAt := sa1Fetched.UpdatedAt

		sa1Fetched.DisplayName = "Service Account Alpha 1 (Updated)"
		sa1Fetched.Disabled = true

		err := repo.UpdateServiceAccount(ctx, sa1Fetched)
		require.NoError(t, err, "UpdateServiceAccount for sa1 should succeed")

		fetchedSA, err := repo.GetServiceAccount(ctx, sa1.ID)
		require.NoError(t, err)
		require.NotNil(t, fetchedSA)
		assert.Equal(t, "Service Account Alpha 1 (Updated)", fetchedSA.DisplayName)
		assert.True(t, fetchedSA.Disabled)
		assert.True(t, fetchedSA.UpdatedAt > originalUpdatedAt, "UpdatedAt should be more recent after update. Got %d, original %d", fetchedSA.UpdatedAt, originalUpdatedAt)
	})

	t.Run("UpdateServiceAccount_ChangeClientEmailToExisting", func(t *testing.T) {
		// Try to update sa1's email to sa2's email (which exists)
		// First, fetch the current state of sa1 to ensure other fields are current for the update
		sa1ToUpdate, errFetch := repo.GetServiceAccount(ctx, sa1.ID)
		require.NoError(t, errFetch, "Fetching sa1 for update failed")

		sa1ToUpdate.ClientEmail = sa2.ClientEmail // Conflicting email

		err := repo.UpdateServiceAccount(ctx, sa1ToUpdate)
		require.Error(t, err, "UpdateServiceAccount to an existing client_email should fail")
	})

	t.Run("UpdateServiceAccount_NotFound", func(t *testing.T) {
		nonExistentSA := &domain.ServiceAccount{ID: "non-existent-sa-id-update", ClientEmail: "no@no.com"}
		err := repo.UpdateServiceAccount(ctx, nonExistentSA)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "service account not found for update")
	})

	t.Run("DeleteServiceAccount", func(t *testing.T) {
		// sa1 and sa2 were created. Delete sa1.
		err := repo.DeleteServiceAccount(ctx, sa1.ID)
		require.NoError(t, err, "DeleteServiceAccount for sa1 should succeed")

		_, err = repo.GetServiceAccount(ctx, sa1.ID)
		assert.Error(t, err, "GetServiceAccount for sa1 should fail after deletion")
		assert.Contains(t, err.Error(), "service account not found")

		// Ensure sa2 still exists
		fetchedSA2, err := repo.GetServiceAccount(ctx, sa2.ID)
		require.NoError(t, err, "sa2 should still exist")
		require.NotNil(t, fetchedSA2)
	})

	t.Run("DeleteServiceAccount_NotFound", func(t *testing.T) {
		err := repo.DeleteServiceAccount(ctx, "non-existent-sa-id-delete")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "service account not found for deletion")
	})
}
