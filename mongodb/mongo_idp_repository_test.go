package mongodb

import (
	"context"
	"fmt"
	"os"
	"testing"
	"time"

	"github.com/pilab-dev/shadow-sso/domain"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.mongodb.org/mongo-driver/v2/mongo"
	"go.mongodb.org/mongo-driver/v2/mongo/options"
)

// Helper function to setup DB for IdPRepository tests
func setupIdPRepoTest(t *testing.T) (domain.IdPRepository, func(), error) {
	mongoURI := os.Getenv("MONGO_TEST_URI") // Using MONGO_TEST_URI
	if mongoURI == "" {
		// This case should be caught by the t.Skip in the test function itself.
		// If we reach here, it implies MONGO_TEST_URI was set, or the test wasn't skipped.
		// For local runs where it might not be skipped but still empty, default.
		mongoURI = "mongodb://localhost:27017"
	}
	dbName := fmt.Sprintf("test_sso_idp_repo_%d", time.Now().UnixNano())

	ctx, cancelSetup := context.WithTimeout(context.Background(), 20*time.Second)
	defer cancelSetup()

	// Direct client connection for test isolation
	client, err := mongo.Connect(options.Client().ApplyURI(mongoURI).SetConnectTimeout(10 * time.Second))
	if err != nil {
		return nil, func() {}, fmt.Errorf("mongo.Connect failed for idp repo test: %w", err)
	}
	if errPing := client.Ping(ctx, nil); errPing != nil {
		client.Disconnect(ctx)
		return nil, func() {}, fmt.Errorf("mongo.Ping failed for idp repo test: %w", errPing)
	}
	db := client.Database(dbName)

	idpRepo, err := NewIdPRepositoryMongo(ctx, db) // Creates collection and indexes
	if err != nil {
		client.Disconnect(ctx)
		return nil, func() {}, fmt.Errorf("NewIdPRepositoryMongo failed: %w", err)
	}

	cleanupFunc := func() {
		mainCtx := context.Background()
		if errDbDrop := db.Drop(mainCtx); errDbDrop != nil {
			t.Logf("Warning: failed to drop database %s during cleanup: %v", dbName, errDbDrop)
		}
		if errDisconnect := client.Disconnect(mainCtx); errDisconnect != nil {
			t.Logf("Warning: failed to disconnect test client during cleanup: %v", errDisconnect)
		}
	}
	return idpRepo, cleanupFunc, nil
}

func TestIdPRepositoryMongo_Integration(t *testing.T) {
	if os.Getenv("MONGO_TEST_URI") == "" { // Standardized skip condition
		t.Skip("Skipping MongoDB integration test: MONGO_TEST_URI not set")
	}

	repo, cleanup, err := setupIdPRepoTest(t)
	require.NoError(t, err, "Failed to setup IdPRepository test")
	defer cleanup()

	ctx := context.Background()
	// now := time.Now().UTC().Truncate(time.Millisecond) // Not directly used in this version

	idp1 := &domain.IdentityProvider{
		// ID generated by AddIdP if empty
		Name:             "Google-OIDC",
		Type:             domain.IdPTypeOIDC,
		IsEnabled:        true,
		OIDCClientID:     "google-client-id",
		OIDCClientSecret: "google-client-secret", // Stored as is for now
		OIDCIssuerURL:    "https://accounts.google.com",
		OIDCScopes:       []string{"openid", "profile", "email"},
		AttributeMappings: []domain.AttributeMapping{
			{ExternalAttributeName: "sub", LocalUserAttribute: "ExternalID"},
			{ExternalAttributeName: "email", LocalUserAttribute: "Email"},
		},
		// CreatedAt, UpdatedAt set by repo
	}
	idp2Disabled := &domain.IdentityProvider{
		Name:          "Okta-OIDC-Disabled",
		Type:          domain.IdPTypeOIDC,
		IsEnabled:     false,
		OIDCClientID:  "okta-client-id",
		OIDCIssuerURL: "https://okta.example.com",
	}

	t.Run("AddIdP_And_GetByIdAndName", func(t *testing.T) {
		err := repo.AddIdP(ctx, idp1)
		require.NoError(t, err, "AddIdP for idp1 should succeed")
		require.NotEmpty(t, idp1.ID, "idp1 ID should be populated")
		require.False(t, idp1.CreatedAt.IsZero())
		require.False(t, idp1.UpdatedAt.IsZero())

		fetchedById, err := repo.GetIdPByID(ctx, idp1.ID)
		require.NoError(t, err, "GetIdPByID for idp1 should succeed")
		require.NotNil(t, fetchedById)
		assert.Equal(t, idp1.Name, fetchedById.Name)
		assert.Equal(t, idp1.OIDCClientID, fetchedById.OIDCClientID)
		assert.Len(t, fetchedById.AttributeMappings, 2)

		fetchedByName, err := repo.GetIdPByName(ctx, idp1.Name)
		require.NoError(t, err, "GetIdPByName for idp1 should succeed")
		require.NotNil(t, fetchedByName)
		assert.Equal(t, idp1.ID, fetchedByName.ID)

		// Add idp2 for other tests
		err = repo.AddIdP(ctx, idp2Disabled)
		require.NoError(t, err, "AddIdP for idp2Disabled should succeed")
	})

	t.Run("AddIdP_DuplicateName", func(t *testing.T) {
		duplicateIdP := &domain.IdentityProvider{Name: idp1.Name, Type: domain.IdPTypeOIDC} // idp1.Name already exists
		err := repo.AddIdP(ctx, duplicateIdP)
		assert.Error(t, err, "AddIdP with duplicate name should fail")
		assert.Contains(t, err.Error(), "already exists")
	})

	t.Run("GetIdP_NotFound", func(t *testing.T) {
		_, err := repo.GetIdPByID(ctx, "non-existent-idp-id")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "identity provider not found by ID")

		_, err = repo.GetIdPByName(ctx, "NonExistent IdP Name")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "identity provider not found by Name")
	})

	t.Run("ListIdPs", func(t *testing.T) {
		// idp1 (enabled), idp2Disabled (disabled)
		allIdPs, err := repo.ListIdPs(ctx, false) // List all
		require.NoError(t, err)
		assert.Len(t, allIdPs, 2, "Should list 2 IdPs when not filtering by enabled")

		enabledIdPs, err := repo.ListIdPs(ctx, true) // List only enabled
		require.NoError(t, err)
		assert.Len(t, enabledIdPs, 1, "Should list 1 enabled IdP")
		if len(enabledIdPs) == 1 {
			assert.Equal(t, idp1.Name, enabledIdPs[0].Name)
		}
	})

	t.Run("UpdateIdP", func(t *testing.T) {
		idp1Fetched, err := repo.GetIdPByID(ctx, idp1.ID)
		require.NoError(t, err)
		originalUpdatedAt := idp1Fetched.UpdatedAt

		idp1Fetched.Name = "Google OIDC Updated"
		idp1Fetched.IsEnabled = false
		idp1Fetched.OIDCScopes = []string{"openid", "email"} // Changed scopes

		err = repo.UpdateIdP(ctx, idp1Fetched)
		require.NoError(t, err, "UpdateIdP for idp1Fetched should succeed")

		updatedIdP, err := repo.GetIdPByID(ctx, idp1.ID)
		require.NoError(t, err)
		assert.Equal(t, "Google OIDC Updated", updatedIdP.Name)
		assert.False(t, updatedIdP.IsEnabled)
		assert.Equal(t, []string{"openid", "email"}, updatedIdP.OIDCScopes)
		assert.True(t, updatedIdP.UpdatedAt.After(originalUpdatedAt))
	})

	t.Run("UpdateIdP_NameToExisting", func(t *testing.T) {
		idp2Fetched, err := repo.GetIdPByID(ctx, idp2Disabled.ID)
		require.NoError(t, err)

		idp1CurrentName := "Google OIDC Updated" // From previous test
		idp2Fetched.Name = idp1CurrentName

		err = repo.UpdateIdP(ctx, idp2Fetched)
		require.Error(t, err, "UpdateIdP name to an existing name should fail")
		assert.Contains(t, err.Error(), "already exists")
	})

	t.Run("UpdateIdP_NotFound", func(t *testing.T) {
		nonExistentIdP := &domain.IdentityProvider{ID: "non-existent-idp-for-update", Name: "No Such IdP"}
		err := repo.UpdateIdP(ctx, nonExistentIdP)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "IdP configuration not found for update")
	})

	t.Run("DeleteIdP", func(t *testing.T) {
		err := repo.DeleteIdP(ctx, idp1.ID) // idp1's name is now "Google OIDC Updated"
		require.NoError(t, err, "DeleteIdP for idp1 should succeed")

		_, err = repo.GetIdPByID(ctx, idp1.ID)
		assert.Error(t, err, "GetIdPByID for idp1 should fail after deletion")
		assert.Contains(t, err.Error(), "identity provider not found by ID")

		// Ensure idp2Disabled still exists
		idp2StillThere, err := repo.GetIdPByID(ctx, idp2Disabled.ID)
		require.NoError(t, err)
		require.NotNil(t, idp2StillThere)
	})

	t.Run("DeleteIdP_NotFound", func(t *testing.T) {
		err := repo.DeleteIdP(ctx, "non-existent-idp-for-delete")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "IdP configuration not found for deletion")
	})
}
