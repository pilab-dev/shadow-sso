package services

import (
	"context"
	"errors"
	"testing"
	"time"

	"connectrpc.com/connect"
	"github.com/pilab-dev/shadow-sso/domain" // For mock_domain.MockClientRepository
	"github.com/pilab-dev/shadow-sso/internal/oidcflow"
	"github.com/pilab-dev/shadow-sso/internal/oidcflow/mocks" // Assuming mocks for FlowStoreRetriever are here or to be created
	ssov1 "github.com/pilab-dev/shadow-sso/gen/proto/sso/v1"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.uber.org/mock/gomock"
	// "github.com/pilab-dev/shadow-sso/client" // For client.Client if used directly
	domain_mocks "github.com/pilab-dev/shadow-sso/domain/mocks" // for domain.MockClientRepository
)

// MockFlowStoreRetriever is a mock of FlowStoreRetriever interface.
// This should ideally be generated by gomock based on the FlowStoreRetriever interface
// defined in oidc_flow_service.go. For now, manually defining for structure.
// If oidcflow.InMemoryFlowStore is used directly, its methods would be mocked if it were an interface.
// Let's assume we have a mock for FlowStoreRetriever.
// The actual mock should be generated from the FlowStoreRetriever interface in oidc_flow_service.go.
// For this test, we'll use the one from internal/oidcflow/mocks if it exists, or define one here.

func TestOidcFlowServiceImpl_GetOidcFlowState_Success(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockFlowStore := mock_oidcflow.NewMockFlowStoreRetriever(ctrl)
	mockClientRepo := domain_mocks.NewMockClientRepository(ctrl) // Using domain's ClientRepository mock
	service := NewOidcFlowService(mockFlowStore, mockClientRepo)

	flowID := "test-flow-id"
	clientID := "test-client-id"
	clientName := "Test Client App"

	flowState := &oidcflow.LoginFlowState{
		FlowID:      flowID,
		ClientID:    clientID,
		Scope:       "openid profile",
		RedirectURI: "http://localhost/callback",
		ExpiresAt:   time.Now().Add(10 * time.Minute),
		OriginalOIDCParams: map[string]string{"response_type": "code", "custom_param": "value"},
		CodeChallenge: "some_challenge", // This should NOT be in the response
	}

	mockClient := &domain.Client{ // Using domain.Client as returned by repository
		ID:   clientID,
		Name: clientName,
		// other fields as necessary
	}


	mockFlowStore.EXPECT().GetFlow(flowID).Return(flowState, nil)
	mockClientRepo.EXPECT().GetClient(gomock.Any(), clientID).Return(mockClient, nil)


	req := connect.NewRequest(&ssov1.GetOidcFlowStateRequest{FlowId: flowID})
	resp, err := service.GetOidcFlowState(context.Background(), req)

	require.NoError(t, err)
	require.NotNil(t, resp.Msg)
	assert.Equal(t, clientID, resp.Msg.ClientId)
	assert.Equal(t, clientName, resp.Msg.ClientName)
	assert.Equal(t, "openid profile", resp.Msg.Scope)
	assert.Equal(t, map[string]string{"response_type": "code", "custom_param": "value"}, resp.Msg.OriginalOidcParams)
	// Ensure sensitive fields like CodeChallenge are not present in ssov1.GetOidcFlowStateResponse definition
}

func TestOidcFlowServiceImpl_GetOidcFlowState_FlowNotFound(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockFlowStore := mock_oidcflow.NewMockFlowStoreRetriever(ctrl)
	mockClientRepo := domain_mocks.NewMockClientRepository(ctrl)
	service := NewOidcFlowService(mockFlowStore, mockClientRepo)

	flowID := "not-found-flow-id"
	mockFlowStore.EXPECT().GetFlow(flowID).Return(nil, oidcflow.ErrFlowNotFound)

	req := connect.NewRequest(&ssov1.GetOidcFlowStateRequest{FlowId: flowID})
	_, err := service.GetOidcFlowState(context.Background(), req)

	require.Error(t, err)
	assert.Equal(t, connect.CodeNotFound, connect.CodeOf(err))
}

func TestOidcFlowServiceImpl_GetOidcFlowState_FlowExpired(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockFlowStore := mock_oidcflow.NewMockFlowStoreRetriever(ctrl)
	mockClientRepo := domain_mocks.NewMockClientRepository(ctrl)
	service := NewOidcFlowService(mockFlowStore, mockClientRepo)

	flowID := "expired-flow-id"
	expiredFlowState := &oidcflow.LoginFlowState{FlowID: flowID, ExpiresAt: time.Now().Add(-1 * time.Minute)}
	mockFlowStore.EXPECT().GetFlow(flowID).Return(expiredFlowState, oidcflow.ErrFlowExpired)

	req := connect.NewRequest(&ssov1.GetOidcFlowStateRequest{FlowId: flowID})
	_, err := service.GetOidcFlowState(context.Background(), req)

	require.Error(t, err)
	assert.Equal(t, connect.CodeNotFound, connect.CodeOf(err), "Expired flow should also return NotFound to client")
}


func TestOidcFlowServiceImpl_GetOidcFlowState_ClientRepoError(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockFlowStore := mock_oidcflow.NewMockFlowStoreRetriever(ctrl)
	mockClientRepo := domain_mocks.NewMockClientRepository(ctrl)
	service := NewOidcFlowService(mockFlowStore, mockClientRepo)

	flowID := "test-flow-id"
	clientID := "test-client-id"
	flowState := &oidcflow.LoginFlowState{FlowID: flowID, ClientID: clientID, ExpiresAt: time.Now().Add(10 * time.Minute)}

	mockFlowStore.EXPECT().GetFlow(flowID).Return(flowState, nil)
	mockClientRepo.EXPECT().GetClient(gomock.Any(), clientID).Return(nil, errors.New("database error"))

	req := connect.NewRequest(&ssov1.GetOidcFlowStateRequest{FlowId: flowID})
	resp, err := service.GetOidcFlowState(context.Background(), req)

	require.NoError(t, err) // Service handles client fetch error gracefully by using clientID as name
	require.NotNil(t, resp.Msg)
	assert.Equal(t, clientID, resp.Msg.ClientId)
	assert.Equal(t, clientID, resp.Msg.ClientName, "ClientName should fallback to ClientId on repo error")

}

func TestOidcFlowServiceImpl_GetOidcFlowState_MissingFlowId(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockFlowStore := mock_oidcflow.NewMockFlowStoreRetriever(ctrl)
	mockClientRepo := domain_mocks.NewMockClientRepository(ctrl)
	service := NewOidcFlowService(mockFlowStore, mockClientRepo)

	req := connect.NewRequest(&ssov1.GetOidcFlowStateRequest{FlowId: ""}) // Empty FlowId
	_, err := service.GetOidcFlowState(context.Background(), req)

	require.Error(t, err)
	assert.Equal(t, connect.CodeInvalidArgument, connect.CodeOf(err))
}
